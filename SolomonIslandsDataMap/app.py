# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/01_app.ipynb.

# %% auto 0
__all__ = ['sol_geo', 'geo_df', 'app', 'server', 'geos', 'cen_vars', 'mytitle', 'mygraph', 'dropdown_geo', 'dropdown_var',
           'navbar', 'base_card', 'SIDEBAR_STYLE', 'sidebar', 'define_map', 'update_geography']

# %% ../nbs/01_app.ipynb 2
from nbdev.showdoc import *
# TODO work out how to get around below hack
try:
    from SolomonIslandsDataMap.load_data import *
except: 
    from load_data import *
import plotly.express as px
import plotly.graph_objects as go
import plotly.io as pio # Unless this is used graphs will not be dynamic?
import json
from git import Repo
import pandas as pd
import numpy as np
from fastcore.test import *
from dash import Dash, dcc, Output, Input, html, Patch, ctx  # pip install dash
import dash_bootstrap_components as dbc    # pip install dash-bootstrap-components
from dash_bootstrap_templates import load_figure_template
import random
import dash_mantine_components as dmc

# %% ../nbs/01_app.ipynb 5
sol_geo = SolomonGeo.load_pickle("/testData/")
geo_df = sol_geo.geo_df

# %% ../nbs/01_app.ipynb 6
# TODO I should build figures and maps in another script
def define_map(sol_df:SolomonGeo # Solomon geo object containing census data to input into map
                )->type(go.Figure()): # Returns a graph object figure
    '''
    Creates and returns the base cloreopath map
    '''
    # TODO - should I update this into a class with methods for updating
    # the other things? Acutally maybe as another function if the update is done through patch
    
    # cols_dd dictates the aggregation that will be visable
    cols_dd = sol_df.geo_levels
    # we need to add this to select which trace 
    # is going to be visible
    visible = np.array(cols_dd)
    # define traces and buttons at once
    traces = []
    buttons = []
    # TODO if fails remember I changed visible from cols_dd
    for value in cols_dd:
        traces.append(go.Choroplethmapbox(
                                geojson=sol_df.get_geojson(agg_filter = value),
                               locations=sol_df.get_df(agg_filter = value).index,
                               z = sol_df.get_df(agg_filter = value)['total_pop'],
                               colorscale="deep",
                                marker_line_width = 0.5,
                                zauto=True,
                visible= True if value==cols_dd[0] else False))
        
    # Show figure
    fig = go.Figure(data=traces)
    # This is in order to get the first title displayed correctly
    first_title = cols_dd[0]
    fig.update_layout(title=f"<b>{first_title}</b>",
                        title_x=0.5,
                        mapbox_style = 'carto-positron',
                        mapbox_zoom = 5,
                        mapbox_center={"lat": -9.565766, "lon": 162.012453},
    )
    fig.update_layout(margin={"r":0,"t":0,"l":0,"b":0})
    
    return fig


# %% ../nbs/01_app.ipynb 11
# Build your components
# FYI the best themes seem to be: [Darkly, Flatly, Minty, Slate, JOURNAL]
app = Dash(__name__, external_stylesheets=[dbc.themes.MINTY])
server = app.server
load_figure_template("minty")

geos = geo_df.loc[:, 'agg'].unique()
cen_vars = sol_geo.census_vars
mytitle = dcc.Markdown(children="## " + cen_vars[-1] + " by " + geos[0]) # TODO This needs a default title
mygraph = dcc.Graph(figure=define_map(sol_geo))

#dropdown_geo = dbc.Dropdown(options=geos,
#                        value=geos[0],  # initial value displayed when page first loads
#                        clearable=False)
dropdown_geo = dmc.SegmentedControl(
                            id="segmented",
                            value=geos[0],
                            data=geos,
                             orientation="vertical",
                            color = 'pink',
                            fullWidth = True,
                            #color = dmc.theme.DEFAULT_COLORS["teal"][3]
    # TODO this color functionality is beyond stupid...
    # TODO definitely change to dbc, even though more complicated get consistent theme.s..
                        ) # TODO consider redoing as theme is not consistent with this library
dropdown_var = dcc.Dropdown(options=cen_vars,
                        value=cen_vars[-1],  # initial value displayed when page first loads
                        clearable=False)

navbar = dbc.NavbarSimple(
    children=[
        dbc.NavItem(dbc.NavLink("Census Data", href="#")),
        dbc.DropdownMenu(
            children=[
                dbc.DropdownMenuItem("More pages coming soon", header=True),
                dbc.DropdownMenuItem("Population Projection", href="#"),
            ],
            nav=True,
            in_navbar=True,
            label="More",
        ),
    ],
    brand="Solomon Islands Data Map",
    brand_href="#",
    color="primary",
    dark=True,
)

# %% ../nbs/01_app.ipynb 13
# todo - turn this eventually into a function

# TODO - make it in future so that clicking on a card updates the current census variable
# selection and it highlights it as clicked.

base_card = dbc.Card(
    dbc.CardBody(
        [
        html.H4(cen_vars[-1]),
        html.Hr(),
        html.H5(sol_geo.get_df(agg_filter = 'province', 
                               var_filter = 'total_pop').sum(), 
                className = "text-center")
        ]
    ) , className="m-2 border-primary mb-3"
)

# %% ../nbs/01_app.ipynb 15
# Note, for now I am not using a sidebar style as I do not want to fix the width
SIDEBAR_STYLE = {
    "position": "fixed",
    "top": 0,
    "left": 0,
    "bottom": 0,
    "width": "24rem",
    "padding": "2rem 1rem",
    #"background-color": "#f8f9fa",
}


sidebar = html.Div(
    [
        html.H2("Filters"),
        html.Hr(),
        dbc.Nav(
            [
                html.P("Geography"), # TODO add a tooltip button here with link to geo explanation
                dropdown_geo,
                html.Br(),
                html.P("Data"), # TODO add a little info button here with link to geo explanation
                dropdown_var,
                #html.Br(),
                #dcc.Dropdown(id = 'three')

            ],
            vertical=True,
            pills=True,
        ),
    ],
    #style=SIDEBAR_STYLE,
)



# %% ../nbs/01_app.ipynb 17
app.layout = dbc.Container([
                dbc.Row([
                    navbar
                ]),
                dbc.Row(
                    [dbc.Col(sidebar, width = 3),
                    dbc.Col([mytitle,
                             mygraph,
                            dbc.Row(
                                [
                                    #dbc.Col(),
                                    dbc.Col([base_card], width = 3)
                                ]
                            )
                            ], width = 9)#, style = {'margin-left':'15px', 'margin-top':'7px', 'margin-right':'15px'})
                     ], justify = 'center'),                    
                ], fluid = True)

# %% ../nbs/01_app.ipynb 19
# Callback allows components to interact

# TODO put title in it's own callback
@app.callback(
    Output(mygraph, 'figure'),
    Output(mytitle, 'children'),
    Input(dropdown_geo, 'value'),
    Input(dropdown_var, 'value'),
    allow_duplicate=True,
    prevent_initial_call=True
)
def update_geography(geo_input:str, # User input from the geography dropdown
                     census_var:str # User input for the census variable
              )->(type(go.Figure()), str): # Returns a graph object figure after being updated and the dynamic title
    '''
    Updates the focus census variable or geography dispalayed on the map
    '''
    patched_figure = Patch()
    button_clicked = ctx.triggered_id

    if button_clicked == dropdown_geo.id:
        # Update disaplayed geography based on 
        for geo in sol_geo.geo_levels:
            i = np.where(sol_geo.geo_levels == geo)[0][0] # Tracks the trace number
            patched_figure['data'][i]['visible'] = geo_input == geo
            print(geo_input == geo)
    elif button_clicked == dropdown_var.id:
        # Update the z values in map to the data for the requested
        # census variable
        
        for geo in sol_geo.geo_levels:
        # Ar updates the z value ie. data disaplyed each time
        # TODO this is fairly inefficient, as we are processing each time
        # Maybe faster framework like polars could help? or caching but would require a lot of caching
            i = np.where(sol_geo.geo_levels == geo)[0][0] # Tracks the trace number
            ar = sol_geo.get_df(agg_filter = geo, var_filter = census_var).values
            ar = ar.reshape((ar.shape[0],))
            patched_figure['data'][i]['z'] = ar

    # returned objects are assigned to the component property of the Output
    return patched_figure, '## Solomon Islands Data map - ' + geo_input

# %% ../nbs/01_app.ipynb 31
# Run app
if __name__=='__main__':
    app.run_server(debug=True, port = random.randint(1000, 9999)) # Random int mitigates port collision
