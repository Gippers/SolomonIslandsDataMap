# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/02_app.ipynb.

# %% auto 0
__all__ = ['sol_geo', 'geo_df', 'app', 'server', 'geos', 'cen_vars', 'mytitle', 'map_graph', 'dropdown_geo', 'dropdown_var',
           'navbar', 'base_card', 'SIDEBAR_STYLE', 'sidebar', 'update_geography', 'update_kpis']

# %% ../nbs/02_app.ipynb 2
from nbdev.showdoc import *
# TODO work out how to get around below hack
try:
    from SolomonIslandsDataMap.load_data import *
    from SolomonIslandsDataMap.dash_components import *
except: 
    from load_data import *
    from dash_components import *
import plotly.express as px
import plotly.graph_objects as go
import plotly.io as pio # Unless this is used graphs will not be dynamic?
import json
from git import Repo
import pandas as pd
import numpy as np
from fastcore.test import *
from dash import Dash, dcc, Output, Input, html, Patch, ctx  # pip install dash
import dash_bootstrap_components as dbc    # pip install dash-bootstrap-components
from dash_bootstrap_templates import load_figure_template
import random
import dash_mantine_components as dmc

# %% ../nbs/02_app.ipynb 5
sol_geo = SolomonGeo.load_pickle("/testData/")
geo_df = sol_geo.geo_df

# %% ../nbs/02_app.ipynb 9
# Build your components
# FYI the best themes seem to be: [Darkly, Flatly, Minty, Slate, JOURNAL]
app = Dash(__name__, external_stylesheets=[dbc.themes.MINTY])
server = app.server
load_figure_template("minty")

geos = geo_df.loc[:, 'agg'].unique()
cen_vars = sol_geo.census_vars
mytitle = dcc.Markdown(children="## " + cen_vars[-1] + " by " + geos[0]) # TODO This needs a default title
map_graph = dcc.Graph(figure=define_map(sol_geo))

#dropdown_geo = dbc.Dropdown(options=geos,
#                        value=geos[0],  # initial value displayed when page first loads
#                        clearable=False)
dropdown_geo = dmc.SegmentedControl(
                            id="segmented",
                            value=geos[0],
                            data=geos,
                             orientation="vertical",
                            color = 'pink',
                            fullWidth = True,
                            #class_name = "btn btn-primary"
                            #color = dmc.theme.DEFAULT_COLORS["teal"][3]
    # TODO this color functionality is beyond stupid...
    # TODO definitely change to dbc, even though more complicated get consistent theme.s..
                        ) # TODO consider redoing as theme is not consistent with this library
dropdown_var = dcc.Dropdown(options=cen_vars,
                        value=cen_vars[-1],  # initial value displayed when page first loads
                        clearable=False)

navbar = dbc.NavbarSimple(
    children=[
        dbc.NavItem(dbc.NavLink("Census Data", href="#")),
        dbc.DropdownMenu(
            children=[
                dbc.DropdownMenuItem("More pages coming soon", header=True),
                dbc.DropdownMenuItem("Population Projection", href="#"),
            ],
            nav=True,
            in_navbar=True,
            label="More",
        ),
    ],
    brand="Solomon Islands Data Map",
    brand_href="#",
    color="primary",
    dark=True,
)

base_card = create_card(sol_geo, 'ward', 'total_pop')

# %% ../nbs/02_app.ipynb 11
# Note, for now I am not using a sidebar style as I do not want to fix the width
SIDEBAR_STYLE = {
    "position": "fixed",
    "top": 0,
    "left": 0,
    "bottom": 0,
    "width": "24rem",
    "padding": "2rem 1rem",
    #"background-color": "#f8f9fa",
}


sidebar = html.Div(
    [
        html.H2("Filters"),
        html.Hr(),
        dbc.Nav(
            [
                html.P("Geography"), # TODO add a tooltip button here with link to geo explanation
                dropdown_geo,
                html.Br(),
                html.P("Data"), # TODO add a little info button here with link to geo explanation
                dropdown_var,
                #html.Br(),
                #dcc.Dropdown(id = 'three')

            ],
            vertical=True,
            pills=True,
        ),
    ],
    #style=SIDEBAR_STYLE,
)



# %% ../nbs/02_app.ipynb 13
app.layout = dbc.Container([
                dbc.Row([
                    navbar
                ]),
                dbc.Row(
                    [dbc.Col(sidebar, width = 2),
                    dbc.Col([mytitle,
                             map_graph,
                            dbc.Row(
                                [
                                    dbc.Col([base_card]),
                                    dbc.Col([base_card]),
                                    dbc.Col([base_card]),
                                    dbc.Col([base_card]),
                                ]
                            )
                            ], width = 10)#, style = {'margin-left':'15px', 'margin-top':'7px', 'margin-right':'15px'})
                     ], justify = 'center'),                    
                ], fluid = True)

# %% ../nbs/02_app.ipynb 15
# Callback allows components to interact

# TODO put title in it's own callback
@app.callback(
    Output(map_graph, 'figure'),
    Output(mytitle, 'children'),
    Input(dropdown_geo, 'value'),
    Input(dropdown_var, 'value'),
    allow_duplicate=True,
    prevent_initial_call=True
)
def update_geography(geo_input:str, # User input from the geography dropdown
                     census_var:str # User input for the census variable
              )->(type(go.Figure()), str): # Returns a graph object figure after being updated and the dynamic title
    '''
    Updates the focus census variable or geography dispalayed on the map
    '''
    patched_figure = Patch()
    button_clicked = ctx.triggered_id

    if button_clicked == dropdown_geo.id:
        # Update disaplayed geography based on 
        for geo in sol_geo.geo_levels:
            i = np.where(sol_geo.geo_levels == geo)[0][0] # Tracks the trace number
            patched_figure['data'][i]['visible'] = geo_input == geo
            print(geo_input == geo)
    elif button_clicked == dropdown_var.id:
        # Update the z values in map to the data for the requested
        # census variable
        
        for geo in sol_geo.geo_levels:
        # Ar updates the z value ie. data disaplyed each time
        # TODO this is fairly inefficient, as we are processing each time
        # Maybe faster framework like polars could help? or caching but would require a lot of caching
            i = np.where(sol_geo.geo_levels == geo)[0][0] # Tracks the trace number
            ar = sol_geo.get_df(agg_filter = geo, var_filter = census_var).values
            ar = ar.reshape((ar.shape[0],))
            patched_figure['data'][i]['z'] = ar

    # returned objects are assigned to the component property of the Output
    return patched_figure, '## Solomon Islands Data map - ' + geo_input

# %% ../nbs/02_app.ipynb 18
@app.callback(
    Output('page-content', 'children'),
    Input(map_graph, 'clickData')
)
def update_kpis(clickData):
    if clickData is None:
        return ""
    else:
        print(clickData,   file = sys.stderr)
        location = clickData['points'][0]['location']
        # filter dataframe by store location, then sum all orders of that store.
        dff = df[df['district']==location]
        print(dff)
        
        # get all orders from this stor location 

        return f'the location of store is: {location}'

# %% ../nbs/02_app.ipynb 29
# Run app
if __name__=='__main__':
    try:
        app.run_server(debug=True, port = random.randint(1000, 9999)) # Random int mitigates port collision
    except:
        print("Cannot run server here")
